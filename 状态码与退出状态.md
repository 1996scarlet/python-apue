# 状态码
我们可以通过`$?`获得当前`shell`的状态码，退出状态码为一个非零数的十进制整数。一般情况下, 如果上一条命令正常执行则返回`0`，否则会产生范围在`1 - 255`之间的整数.

```bash
> date
Fri 21 Feb 2020 07:22:12 PM CST
> echo $?
0
```
在脚本中通过`exit 状态码`的方式人为指定退出状态码, 如果脚本以不带参数的`exit`结束或者直接不写`exit`, 则整个脚本的退出状态码由脚本中最后执行的命令决定, 也就等价于`exit $?`.

# 退出状态
通过状态码我们可以知道上一条命令是否执行成功，思考下面这条命令：

```bash
# 命令1：能ping通baidu.com则输出`baidu.com is up`，否则输出`baidu.com is down`。
ping -c1 baidu.com &> /dev/null && echo 'baidu.com is up' || echo 'baidu.com is down'
```

分析这条命令，首先需要复习C语言中的逻辑运算符, 在编译阶段做的优化：

* 对于逻辑与运算符&&, 以eq1 && eq2为例, 只有当两边都为True才会返回True, 因此当eq1为False时,eq2不会执行。
* 对于逻辑或运算符||, 以eq1 || eq2为例, 只要两边有一个True就会返回True, 因此当eq1为True时,eq2不会执行。

而shell作为解释型语言，其在解释过程中对逻辑运算符也做了相同的优化。我们令：
`A`表示`ping -c1 baidu.com &> /dev/null`
`B`表示`echo 'baidu.com is up'`
`C`表示`echo 'baidu.com is down'`
则针对`命令1：A && B || C`，我们可以进行如下讨论：
* 当`A`执行成功时，他的退出状态为真（尽管状态码为`0`，注意不要混淆状态码与退出状态），则逻辑与运算符右侧的`B`会被执行且退出状态为真（假设`echo`总是执行成功），而逻辑或运算符右侧的`C`不会被执行。
* 当`A`执行失败时，他的退出状态为假（状态码非零），则逻辑与运算符右侧的`B`会被跳过，`A && B`整体返回假，这导致逻辑或运算符右侧的`C`被执行。

现在我们继续思考下面这段shell脚本：
```shell
#!/usr/bin/bash
ping -c1 baidu.com &> /dev/null
if [ $? -eq 0 ] # 根据状态码判断上一个命令是否执行成功
then
    echo 'baidu.com is up'
else
    echo 'baidu.com is down'
fi
```
这个脚本所实现的功能与`命令1`完全相同，这说明`shell`中的逻辑运算符会自动帮我们做状态码判断，从而获得上一个命令的退出状态。